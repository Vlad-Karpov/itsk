------------------------------------------------------------------------------------------------------------------------
SOLID

SRP: Single Responsibility Principle — принцип единственной ответствен- ности .
Действительное следствие закона Конвея: лучшей является такая струк- тура программной системы, которая формируется в
основном под вли- янием социальной структуры организации, использующей эту систему, поэтому каждый программный модуль
имеет одну и только одну причину для изменения .

OCP: Open-Closed Principle — принцип открытости/закрытости .
Этот принцип был сформулирован Бертраном Мейером в 1980-х годах . Суть его сводится к следующему: простая для изменения
система должна предусматривать простую возможность изменения ее поведения добав- лением нового, но не изменением
существующего кода .

LSP: Liskov Substitution Principle — принцип подстановки Барбары Лисков .
Определение подтипов Барбары Лисков известно с 1988 года . В двух сло- вах, этот принцип утверждает, что для создания
программных систем из взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять
эти части друг другом .

ISP: Interface Segregation Principle — принцип разделения интерфейсов . Этот принцип призывает разработчиков
программного обеспечения избегать зависимости от всего, что не используется .

DIP: Dependency Inversion Principle — принцип инверсии зависимости.
Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали . Напротив,
детали должны зависеть от политики .

------------------------------------------------------------------------------------------------------------------------
PECS
https://habr.com/ru/post/207360/

Если метод имеет аргументы с параметризованным типом (например, Collection или Predicate), то в случае, если аргумент -
производитель (producer), нужно использовать ? extends T, а если аргумент - потребитель (consumer),
нужно использовать ? super T.
Производитель и потребитель, кто это такие? Очень просто: если метод читает данные из аргумента, то этот аргумент -
производитель, а если метод передаёт данные в аргумент, то аргумент является потребителем. Важно заметить, что
определяя производителя или потребителя, мы рассматриваем только данные типа T.

